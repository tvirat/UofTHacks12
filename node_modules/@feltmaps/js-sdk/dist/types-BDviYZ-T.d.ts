import { ZodRawShape, objectOutputType, ZodTypeAny, z } from 'zod';

/**
 * A selection of generic utility types
 */

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PromiseOrNot<T> = T | Promise<T>;
/**
 * A better type inference for zod schemas that retains the TSDoc comments
 * from the members in the compiled output.
 */
type zInfer<T extends {
    shape: ZodRawShape;
}> = objectOutputType<T["shape"], ZodTypeAny, "strip">;

/**
 * @group Elements
 */
interface Element {
    /**
     * The string identifying the element
     */
    id: string;
    /**
     * The type of element, such as a Place, Polygon, Line, Route, etc.
     */
    type: string;
    /**
     * The ID of the element group that the element belongs to, or null
     * if the element is not inside an element group.
     */
    groupId: string | null;
    /**
     * The name of the element can be displayed in the Legend, depending
     * on how the element's legend is configured in its style.
     */
    name: string | null;
    /**
     * The element description forms part of the element's metadata. This is visible
     * to users via the element info button in the legend.
     */
    description: string | null;
    /**
     * The attributes of the element, which can be added via the Element Inspector
     * under the Detail tab.
     */
    attributes: Record<string, unknown>;
}
/**
 * @group Element Groups
 */
interface ElementGroup {
    /**
     * A string identifying the element group.
     */
    id: string;
    /**
     * The name of the element group. This is shown in the legend.
     */
    name: string;
    /**
     * The caption of the element group. This is shown in the legend.
     */
    caption: string | null;
    /**
     * The ids of the elements in the element group.
     *
     * @remarks
     * You can use these ids to get the full element objects via the `getElements` method.
     */
    elementIds: Array<string>;
    /**
     * Whether the element group is visible or not.
     */
    visible: boolean;
    /**
     * Whether the element group is shown in the legend or not.
     */
    shownInLegend: boolean;
}
/**
 * The constraints to apply when getting elements.
 *
 * @group Elements
 */
interface GetElementsConstraint extends zInfer<typeof GetElementsConstraintSchema> {
}
declare const GetElementsConstraintSchema: z.ZodObject<{
    /**
     * The ids of the elements to get.
     */
    ids: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    ids?: string[] | undefined;
}, {
    ids?: string[] | undefined;
}>;
/**
 * The constraints to apply when getting element groups.
 *
 * @group Element Groups
 */
interface GetElementGroupsConstraint extends zInfer<typeof GetElementGroupsConstraintSchema> {
}
/**
 * @ignore
 */
declare const GetElementGroupsConstraintSchema: z.ZodObject<{
    /**
     * The ids of the element groups to get.
     */
    ids: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    ids?: string[] | undefined;
}, {
    ids?: string[] | undefined;
}>;
/**
 * The parameters for the `onElementChange` listener.
 *
 * @group Elements
 */
interface ElementChangeCallbackParams {
    /**
     * The new data for the element or null if the element was removed.
     */
    element: Element | null;
}
/**
 * The parameters for the `onElementGroupChange` listener.
 *
 * @group Element Groups
 */
interface ElementGroupChangeCallbackParams {
    elementGroup: ElementGroup | null;
}

/**
 * Represents a point in world coordinates.
 */
interface LatLng {
    latitude: number;
    longitude: number;
}
/**
 * A tuple representing a longitude and latitude coordinate.
 *
 * This is used hen serializing geometry because that's the standard used in
 * GeoJSON.
 */
type LngLatTuple = [longitude: number, latitude: number];
/**
 * A GeoJSON-like point geometry.
 */
type PointGeometry = {
    type: "Point";
    coordinates: LngLatTuple;
};
/**
 * A GeoJSON-like polygon geometry.
 */
type PolygonGeometry = {
    type: "Polygon";
    coordinates: LngLatTuple[][];
};
/**
 * A GeoJSON-like multi-polygon geometry.
 */
type MultiPolygonGeometry = {
    type: "MultiPolygon";
    coordinates: PolygonGeometry["coordinates"][];
};
/**
 * A GeoJSON-like line string geometry.
 */
type LineStringGeometry = {
    type: "LineString";
    coordinates: LngLatTuple[];
};
/**
 * A GeoJSON-like multi-line string geometry.
 */
type MultiLineStringGeometry = {
    type: "MultiLineString";
    coordinates: LineStringGeometry["coordinates"][];
};
/**
 * A GeoJSON-like geometry of any type
 */
type Geometry = PointGeometry | PolygonGeometry | LineStringGeometry | MultiLineStringGeometry | MultiPolygonGeometry;
/**
 * @ignore
 * @internal
 */
declare const FeltZoomSchema: z.ZodNumber;
/**
 * The zoom level of the map.
 *
 * It is a floating-point number between 1 and 23, where 1 is the most
 * zoomed out and 23 is the most zoomed in.
 *
 * @group Types
 * @public
 */
type FeltZoom = z.infer<typeof FeltZoomSchema>;
/**
 * @ignore
 * @internal
 */
declare const FeltBoundarySchema: z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>;
/**
 * The edges of the map in the form of a bounding box.
 *
 * The boundary is a tuple of the form `[west, south, east, north]`.
 *
 * @group Types
 * @public
 */
type FeltBoundary = z.infer<typeof FeltBoundarySchema>;
/**
 * The parameters for the methods that change the visibility of entities.
 *
 * @public
 * @category Visibility
 */
interface SetVisibilityRequest extends zInfer<typeof SetVisibilityRequestSchema> {
}
/**
 * @internal
 */
declare const SetVisibilityRequestSchema: z.ZodObject<{
    /**
     * The ids of the entities you want to change the visibility of.
     */
    show: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    hide: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    show?: string[] | undefined;
    hide?: string[] | undefined;
}, {
    show?: string[] | undefined;
    hide?: string[] | undefined;
}>;

/**
 * A feature is a single geographical item in a layer.
 * The unique ID for a feature is a compound key made up of the layer ID and the feature ID.
 */
interface Feature {
    /**
     * The identifier of the feature, unique within the layer.
     */
    id: string | number;
    /**
     * The identifier of the layer that the feature belongs to.
     */
    layerId: string;
    /**
     * The type of geometry of the feature.
     */
    geometryType: "Point" | "LineString" | "Polygon" | "MultiPolygon" | (string & {});
    /**
     * The properties of the feature, as a bag of attributes.
     */
    properties: Record<string, unknown>;
}
/**
 * A raster pixel value for a specific layer.
 *
 * @interface
 */
type RasterValue = {
    /**
     * The value of the pixel.
     */
    value: number;
    /**
     * The ID of the layer that the pixel belongs to.
     */
    layerId: string;
    /**
     * The name of the category that the pixel belongs to.
     */
    categoryName: null | string;
    /**
     * The color of the pixel. Each value is between 0 and 255.
     */
    color: null | {
        r: number;
        g: number;
        b: number;
        a: number;
    };
};

/**
 * This describes the processing status of a layer.
 *
 * The various values are:
 * - `processing`: The layer has been uploaded or updated and is still processing.
 * - `completed`: The layer has been processed and can be viewed on the map.
 * - `failed`: The layer failed to process and cannot be viewed on the map.
 * - `incomplete`: The layer has not been processed.
 *
 * @group Layers
 */
type LayerProcessingStatus = z.infer<typeof LayerProcessingStatusSchema>;
declare const LayerProcessingStatusSchema: z.ZodEnum<["processing", "completed", "failed", "incomplete"]>;
/**
 * @group Layers
 */
interface Layer {
    /**
     * The string identifying the layer
     */
    id: string;
    /**
     * The ID of the layer group that the layer belongs to.
     *
     * Layers that appear at the root level in Felt will not have a group ID.
     */
    groupId: string | null;
    /**
     * The name of the layer can be displayed in the Legend, depending
     * on how the layer's legend is configured in its style.
     */
    name: string;
    /**
     * The layer's caption is shown in the legend.
     */
    caption: string | null;
    /**
     * The layer description forms part of the layer's metadata. This is visible
     * to users via the layer info button in the legend.
     */
    description: string | null;
    /**
     * Whether the layer is visible or not.
     */
    visible: boolean;
    /**
     * Whether the layer is shown in the legend or not.
     */
    shownInLegend: boolean;
    /**
     * The FSL style for the layer.
     *
     * See the [FSL documentation](https://developers.felt.com/felt-style-language) for details
     * on how to read and write styles.
     *
     * As the types of the styles are very complex, we return `object` here and advise that you
     * program defensively while reading the styles.
     */
    style: object;
    /**
     * The current processing status of the layer.
     */
    status: LayerProcessingStatus;
    /**
     * The geometry type of the layer.
     *
     * @remarks
     * This will generally be one of:
     * - `"Point"`
     * - `"Line"`
     * - `"Polygon"`
     * - `"Raster"`
     * - `null`
     *
     * When the layer is processing, or it is a data-only layer, it will be null. You should
     * expect this to be able to be any string, however, as more geometry types can be added
     * in the future.
     */
    geometryType: string | null;
    /**
     * The bounding box of the layer. If the layer is processing, or the bounds have otherwise
     * not been calculated or are not available, this will be `null`.
     *
     * {@link FeltBoundary}
     */
    bounds: FeltBoundary | null;
}
/**
 * @group Layer Groups
 */
interface LayerGroup {
    /**
     * A string identifying the layer group.
     */
    id: string;
    /**
     * The name of the layer group. This is shown in the legend.
     */
    name: string;
    /**
     * The caption of the layer group. This is shown in the legend.
     */
    caption: string | null;
    /**
     * The ids of the layers in the layer group.
     *
     * @remarks
     * You can use these ids to get the full layer objects via the `getLayers` method.
     */
    layerIds: Array<string>;
    /**
     * Whether the layer group is visible or not.
     */
    visible: boolean;
    /**
     * Whether the layer group is shown in the legend or not.
     */
    shownInLegend: boolean;
    /**
     * The bounding box of the layer group.
     *
     * {@link FeltBoundary}
     */
    bounds: FeltBoundary | null;
}
/**
 * The constraints to apply when getting layers.
 *
 * @group Layers
 */
interface GetLayersConstraint extends zInfer<typeof GetLayersConstraintSchema> {
}
/**
 * @ignore
 */
declare const GetLayersConstraintSchema: z.ZodObject<{
    /**
     * The ids of the layers to get.
     */
    ids: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    ids?: string[] | undefined;
}, {
    ids?: string[] | undefined;
}>;
/**
 * The constraints to apply when getting layer groups.
 *
 * @group Layer Groups
 */
interface GetLayerGroupsConstraint extends zInfer<typeof GetLayerGroupsFilterSchema> {
}
/**
 * @ignore
 */
declare const GetLayerGroupsFilterSchema: z.ZodObject<{
    /**
     * The ids of the layer groups to get.
     */
    ids: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    ids?: string[] | undefined;
}, {
    ids?: string[] | undefined;
}>;
/**
 * The parameters for the `onLayerChange` listener.
 *
 * @group Layers
 */
interface LayerChangeCallbackParams {
    /**
     * The new data for the layer or null if the layer was removed.
     */
    layer: Layer | null;
}
/**
 * The parameters for the `onLayerGroupChange` listener.
 *
 * @group Layer Groups
 */
interface LayerGroupChangeCallbackParams {
    layerGroup: LayerGroup | null;
}
/**
 * A legend item, which often represents a sub-class of features in a
 * layer in the case of categorical or classed layers.
 *
 * @group Legend Items
 */
interface LegendItem extends LegendItemIdentifier {
    /**
     * The title of the legend item.
     */
    title: string | Array<string>;
    /**
     * Whether the title depends on the zoom level or not. If it does, you
     * need to call `getLegendItem` when the zoom level changes.
     *
     * Note that as the zoom level changes, the `onLegendItemChange` handler
     * will not be called, so you need to call `getLegendItem` yourself.
     */
    titleDependsOnZoom: boolean;
    /**
     * Whether the legend item is visible or not.
     */
    visible: boolean;
}
/**
 * The identifier for a legend item. It is a compound key of the layer to
 * which the legend item belongs and the legend item's own id.
 *
 * @group Legend Items
 */
interface LegendItemIdentifier extends zInfer<typeof LegendItemIdentifierSchema> {
}
/** @ignore */
declare const LegendItemIdentifierSchema: z.ZodObject<{
    /**
     * The id of the legend item.
     */
    id: z.ZodString;
    /**
     * The id of the layer the legend item belongs to.
     */
    layerId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    layerId: string;
}, {
    id: string;
    layerId: string;
}>;
/**
 * Constraints for legend items. If nothing is passed, all legend items will be returned.
 *
 * @group Legend Items
 */
interface LegendItemsConstraint extends zInfer<typeof LegendItemsConstraintSchema> {
}
/** @ignore */
declare const LegendItemsConstraintSchema: z.ZodObject<{
    /**
     * Array of legend item identifiers to constrain by.
     */
    ids: z.ZodOptional<z.ZodArray<z.ZodObject<{
        /**
         * The id of the legend item.
         */
        id: z.ZodString;
        /**
         * The id of the layer the legend item belongs to.
         */
        layerId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        id: string;
        layerId: string;
    }, {
        id: string;
        layerId: string;
    }>, "many">>;
    /**
     * Array of layer ids to constrain legend items by.
     */
    layerIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    ids?: {
        id: string;
        layerId: string;
    }[] | undefined;
    layerIds?: string[] | undefined;
}, {
    ids?: {
        id: string;
        layerId: string;
    }[] | undefined;
    layerIds?: string[] | undefined;
}>;
/**
 * The parameters for the `onLegendItemChange` listener.
 *
 * @group Legend Items
 */
interface LegendItemChangeCallbackParams {
    /**
     * The new data for the legend item or null if the legend item was removed.
     */
    legendItem: LegendItem | null;
}
/**
 * Constraints for the `getRenderedFeatures` method. This can include layer constriants, spatial constraints, or both. If no constraints are
 * provided, all rendered features will be returned.
 *
 * @group Layers
 */
interface GetRenderedFeaturesConstraint extends zInfer<typeof GetRenderedFeaturesConstraintSchema> {
    /**
     * The area to query for rendered features. This can be specific coordinates or a {@link FeltBoundary}. If omitted, the entire viewport will be queried.
     */
    areaQuery?: {
        coordinates: LatLng;
    } | {
        boundary: FeltBoundary;
    };
}
/** @ignore */
declare const GetRenderedFeaturesConstraintSchema: z.ZodObject<{
    /**
     * The ids of the layers to get rendered features for.
     */
    layerIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    areaQuery: z.ZodOptional<z.ZodUnion<[z.ZodObject<{
        coordinates: z.ZodObject<{
            latitude: z.ZodNumber;
            longitude: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            latitude: number;
            longitude: number;
        }, {
            latitude: number;
            longitude: number;
        }>;
    }, "strip", z.ZodTypeAny, {
        coordinates: {
            latitude: number;
            longitude: number;
        };
    }, {
        coordinates: {
            latitude: number;
            longitude: number;
        };
    }>, z.ZodObject<{
        boundary: z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>;
    }, "strip", z.ZodTypeAny, {
        boundary: [number, number, number, number];
    }, {
        boundary: [number, number, number, number];
    }>]>>;
}, "strip", z.ZodTypeAny, {
    layerIds?: string[] | undefined;
    areaQuery?: {
        coordinates: {
            latitude: number;
            longitude: number;
        };
    } | {
        boundary: [number, number, number, number];
    } | undefined;
}, {
    layerIds?: string[] | undefined;
    areaQuery?: {
        coordinates: {
            latitude: number;
            longitude: number;
        };
    } | {
        boundary: [number, number, number, number];
    } | undefined;
}>;

/**
 * @group Filters
 */
type FilterLogicGate = z.infer<typeof FilterLogicGateSchema>;
declare const FilterLogicGateSchema: z.ZodEnum<["and", "or"]>;
/**
 * @group Filters
 */
type FilterExpression = z.infer<typeof FilterExpressionSchema>;
declare const FilterExpressionSchema: z.ZodUnion<[z.ZodTuple<[z.ZodUnion<[z.ZodString, z.ZodNull]>, z.ZodEnum<["in", "ni"]>, z.ZodUnion<[z.ZodArray<z.ZodUnion<[z.ZodNumber, z.ZodString, z.ZodBoolean, z.ZodNull]>, "many">, z.ZodNull]>], null>, z.ZodTuple<[z.ZodUnion<[z.ZodString, z.ZodNull]>, z.ZodEnum<["lt", "gt", "le", "ge", "eq", "ne", "cn", "nc", "is", "isnt"]>, z.ZodUnion<[z.ZodNumber, z.ZodString, z.ZodBoolean, z.ZodNull]>], null>]>;
/**
 * @group Filters
 */
type FilterTernary = [
    FilterTernary | FilterExpression | null | boolean,
    FilterLogicGate,
    FilterTernary | FilterExpression | null | boolean
];
/**
 *
 * Filters can be used to change which features in a layer are rendered. Filters can be
 * applied to a layer by the `setLayerFilters` method on the Felt controller.
 *
 * @remarks
 * The possible operators are:
 * - `lt`: Less than
 * - `gt`: Greater than
 * - `le`: Less than or equal to
 * - `ge`: Greater than or equal to
 * - `eq`: Equal to
 * - `ne`: Not equal to
 * - `cn`: Contains
 * - `nc`: Does not contain
 *
 * The allowed boolean operators are:
 * - `and`: Logical AND
 * - `or`: Logical OR
 *
 * @example
 * ```typescript
 * // a simple filter
 * felt.setLayerFilters({
 *   layerId: "layer-1",
 *   filters: ["AREA", "gt", 30_000],
 * });
 *
 * // compound filters can be constructed using boolean logic:
 * felt.setLayerFilters({
 *   layerId: "layer-1",
 *   filters: [["AREA", "gt", 30_000], "and", ["COLOR", "eq", "red"]]
 * })
 * ```
 *
 * @group Filters
 */
type Filters = FilterTernary | FilterExpression | null | boolean;
/**
 * The filters that are currently set on a layer.
 *
 * A layer's filters are the combination of various different places
 * in which filters can be applied.
 *
 * @group Filters
 */
interface LayerFilters {
    /**
     * Filters that are set in the layer's style. These are the lowest level
     * of filters, and can only be set by editing the map.
     */
    style: Filters;
    /**
     * Filters that are set in the layer's components, which are interactive
     * elements in the legend. These can be set by viewers for their own session,
     * but their default value can be set by the map creator.
     */
    components: Filters;
    /**
     * Filters that are set ephemerally by viewers in their own session.
     *
     * These are the filters that are set when the `setLayerFilters` method is
     * called. There is no way to set these in the Felt UI - they can only be
     * set using the SDK.
     */
    ephemeral: Filters;
    /**
     * The combined result of all the filters set on the layer.
     */
    combined: Filters;
}

/**
 * The event object passed to the interaction listeners.
 */
interface MapInteractionEvent {
    /**
     * The cursor position in world coordinates.
     */
    coordinate: LatLng;
    /**
     * The vector features that are under the cursor.
     */
    features: Array<Feature>;
    /**
     * The raster pixel values that are under the cursor.
     */
    rasterValues: Array<RasterValue>;
}

/**
 * A reference to any kind of entity in the map.
 *
 * @remarks
 * EntityNodes are used when you have some collection of entities and you need to
 *
 * @group Entity Node
 */
type EntityNode = ElementNode | ElementGroupNode | LayerNode | LayerGroupNode | FeatureNode;
/**
 * References an element on the map.
 *
 * @interface
 * @group Entity Nodes
 */
type ElementNode = {
    type: "element";
    entity: Element;
};
/**
 * References an element group.
 *
 * @interface
 * @group Entity Nodes
 */
type ElementGroupNode = {
    type: "elementGroup";
    entity: ElementGroup;
};
/**
 * References a layer on the map.
 *
 * @interface
 * @group Entity Nodes
 */
type LayerNode = {
    type: "layer";
    entity: Layer;
};
/**
 * References a layer group on the map.
 *
 * @interface
 * @group Entity Nodes
 */
type LayerGroupNode = {
    type: "layerGroup";
    entity: LayerGroup;
};
/**
 * References a feature on the map.
 *
 * @interface
 * @group Entity Nodes
 */
type FeatureNode = {
    type: "feature";
    entity: Feature;
};
/**
 * The options for selecting a feature in a layer.
 */
interface FeatureSelection extends zInfer<typeof FeatureSelectionSchema> {
}
/**
 * @ignore
 */
declare const FeatureSelectionSchema: z.ZodObject<{
    /**
     * The id of the feature to select.
     */
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    /**
     * The id of the layer that the feature belongs to.
     */
    layerId: z.ZodString;
    /**
     * Whether to show the feature's popup, if it is configured in the layer's style.
     *
     * @default true
     */
    showPopup: z.ZodOptional<z.ZodBoolean>;
    /**
     * Whether to center the view on the feature after selecting it.
     *
     * When true, the viewport will be centered on the feature and zoomed to fit the feature
     * in the viewport. If you need to control the zoom level to prevent it zooming in too
     * far, you can pass an object with a `maxZoom` property.
     *
     * This is useful for avoiding zooming in too far on point features, or if you want
     * to maintain the current zoom level.
     *
     * @default true
     */
    fitViewport: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodObject<{
        maxZoom: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        maxZoom: number;
    }, {
        maxZoom: number;
    }>]>>;
}, "strip", z.ZodTypeAny, {
    id: string | number;
    layerId: string;
    showPopup?: boolean | undefined;
    fitViewport?: boolean | {
        maxZoom: number;
    } | undefined;
}, {
    id: string | number;
    layerId: string;
    showPopup?: boolean | undefined;
    fitViewport?: boolean | {
        maxZoom: number;
    } | undefined;
}>;

/**
 * The input type for setting the viewport to a particular center and zoom.
 *
 * @group Types
 */
interface ViewportCenterZoom extends zInfer<typeof ViewportCenterZoomSchema> {
    /**
     * The center of the viewport in latitude and longitude.
     */
    center: LatLng;
    /**
     * The zoom level of the viewport.
     */
    zoom: FeltZoom;
}
declare const ViewportCenterZoomSchema: z.ZodObject<{
    center: z.ZodObject<{
        latitude: z.ZodNumber;
        longitude: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        latitude: number;
        longitude: number;
    }, {
        latitude: number;
        longitude: number;
    }>;
    zoom: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    center: {
        latitude: number;
        longitude: number;
    };
    zoom: number;
}, {
    center: {
        latitude: number;
        longitude: number;
    };
    zoom: number;
}>;
/**
 * @group Types
 *
 * The current state of the viewport, including the derived bounds.
 */
interface ViewportState {
    /**
     * The center of the viewport in latitude and longitude.
     *
     * {@link LatLng}
     */
    center: LatLng;
    /**
     * The zoom level of the viewport.
     *
     * {@link FeltZoom}
     */
    zoom: FeltZoom;
    /**
     * The bounding box of the viewport.
     *
     * This is derived, and depends on the center and zoom of the viewport, as
     * well as its size.
     *
     * {@link FeltBoundary}
     */
    bounds: FeltBoundary;
}
/**
 * The parameters for the `setViewport` method.
 *
 * @group Types
 */
interface SetViewportCenterZoomParams extends zInfer<typeof SetViewportCenterZoomParamsSchema> {
}
declare const SetViewportCenterZoomParamsSchema: z.ZodObject<{
    center: z.ZodOptional<z.ZodObject<{
        latitude: z.ZodNumber;
        longitude: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        latitude: number;
        longitude: number;
    }, {
        latitude: number;
        longitude: number;
    }>>;
    zoom: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    center?: {
        latitude: number;
        longitude: number;
    } | undefined;
    zoom?: number | undefined;
}, {
    center?: {
        latitude: number;
        longitude: number;
    } | undefined;
    zoom?: number | undefined;
}>;
/**
 * The parameters for the `fitViewportToBounds` method.
 *
 * @group Types
 */
interface ViewportFitBoundsParams extends zInfer<typeof ViewportFitBoundsParamsSchema> {
    /**
     * The bounds to fit the viewport to.
     *
     * {@link FeltBoundary}
     */
    bounds: FeltBoundary;
}
declare const ViewportFitBoundsParamsSchema: z.ZodObject<{
    bounds: z.ZodTuple<[z.ZodNumber, z.ZodNumber, z.ZodNumber, z.ZodNumber], null>;
}, "strip", z.ZodTypeAny, {
    bounds: [number, number, number, number];
}, {
    bounds: [number, number, number, number];
}>;

export type { FilterTernary as A, ElementGroupNode as B, ElementNode as C, FeatureNode as D, Element as E, Filters as F, Geometry as G, LayerGroupNode as H, LayerNode as I, FeltBoundary as J, FeltZoom as K, Layer as L, MapInteractionEvent as M, LatLng as N, LineStringGeometry as O, LngLatTuple as P, MultiLineStringGeometry as Q, RasterValue as R, SetVisibilityRequest as S, MultiPolygonGeometry as T, PointGeometry as U, ViewportState as V, PolygonGeometry as W, UnionToIntersection as X, PromiseOrNot as Y, GetElementsConstraint as a, ElementGroup as b, GetElementGroupsConstraint as c, ElementChangeCallbackParams as d, ElementGroupChangeCallbackParams as e, GetLayersConstraint as f, LayerChangeCallbackParams as g, LayerGroup as h, GetLayerGroupsConstraint as i, LayerGroupChangeCallbackParams as j, LegendItemIdentifier as k, LegendItem as l, LegendItemsConstraint as m, LegendItemChangeCallbackParams as n, LayerFilters as o, GetRenderedFeaturesConstraint as p, Feature as q, EntityNode as r, FeatureSelection as s, SetViewportCenterZoomParams as t, ViewportFitBoundsParams as u, ViewportCenterZoom as v, LayerProcessingStatus as w, FilterExpression as x, FilterLogicGate as y, zInfer as z };
