import { E as Element, G as Geometry, a as GetElementsConstraint, b as ElementGroup, c as GetElementGroupsConstraint, S as SetVisibilityRequest, d as ElementChangeCallbackParams, e as ElementGroupChangeCallbackParams, L as Layer, f as GetLayersConstraint, g as LayerChangeCallbackParams, h as LayerGroup, i as GetLayerGroupsConstraint, j as LayerGroupChangeCallbackParams, k as LegendItemIdentifier, l as LegendItem, m as LegendItemsConstraint, n as LegendItemChangeCallbackParams, o as LayerFilters, F as Filters, p as GetRenderedFeaturesConstraint, q as Feature, M as MapInteractionEvent, r as EntityNode, s as FeatureSelection, z as zInfer, V as ViewportState, t as SetViewportCenterZoomParams, u as ViewportFitBoundsParams, v as ViewportCenterZoom } from './types-BDviYZ-T.js';
export { B as ElementGroupNode, C as ElementNode, D as FeatureNode, J as FeltBoundary, K as FeltZoom, x as FilterExpression, y as FilterLogicGate, A as FilterTernary, N as LatLng, H as LayerGroupNode, I as LayerNode, w as LayerProcessingStatus, O as LineStringGeometry, P as LngLatTuple, Q as MultiLineStringGeometry, T as MultiPolygonGeometry, U as PointGeometry, W as PolygonGeometry, R as RasterValue } from './types-BDviYZ-T.js';
import { z } from 'zod';

/**
 * The Elements controller allows you to get information about the elements on the
 * map, and make changes to their visibility.
 *
 * @group Controller
 * @public
 */
interface ElementsController {
    /**
     * Get a single element from the map by its id.
     *
     * @example
     * ```typescript
     * const element = await felt.getElement("element-1");
     * ```
     * @returns The requested element.
     */
    getElement(
    /**
     * The id of the element you want to get.
     */
    id: string): Promise<Element | null>;
    /**
     * Get the geometry of an element.
     *
     * @example
     * ```typescript
     * const geometry = await felt.getElementGeometry("element-1");
     * console.log(geometry?.type, geometry?.coordinates);
     * ```
     */
    getElementGeometry(
    /**
     * The id of the element you want to get the geometry of.
     */
    id: string): Promise<Geometry | null>;
    /**
     * Gets elements from the map, according to the constraints supplied. If no
     * constraints are supplied, all elements will be returned.
     *
     * @remarks The elements in the map, ordered by the order specified in Felt. This is not
     * necessarily the order that they are drawn in, as Felt draws points above
     * lines and lines above polygons, for instance.
     *
     * @example
     * ```typescript
     * const elements = await felt.getElements();
     * ```
     * @returns All elements on the map.
     */
    getElements(
    /**
     * The constraints to apply to the elements returned from the map.
     */
    constraint?: GetElementsConstraint): Promise<Array<Element | null>>;
    /**
     * Get an element group from the map by its id.
     *
     * @example
     * ```typescript
     * felt.getElementGroup("element-group-1");
     * ```
     * @returns The requested element group.
     */
    getElementGroup(id: string): Promise<ElementGroup | null>;
    /**
     * Gets element groups from the map, according to the filters supplied. If no
     * constraints are supplied, all element groups will be returned in rendering order.
     *
     * @example
     * ```typescript
     * const elementGroups = await felt.getElementGroups({ ids: ["element-group-1", "element-group-2"] });
     * ```
     * @returns The requested element groups.
     */
    getElementGroups(
    /**
     * The constraints to apply to the element groups returned from the map.
     */
    constraint?: GetElementGroupsConstraint): Promise<Array<ElementGroup | null>>;
    /**
     * Hide or show element groups with the given ids.
     *
     * @example
     * ```typescript
     * felt.setElementGroupVisibility({ show: ["element-group-1", "element-group-2"], hide: ["element-group-3"] });
     * ```
     */
    setElementGroupVisibility(visibility: SetVisibilityRequest): Promise<void>;
    /**
     * Adds a listener for when an element changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onElementChange({
     *   options: { id: "element-1" },
     *   handler: ({element}) => console.log(element.id),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onElementChange(args: {
        options: {
            /**
             * The id of the element to listen for changes to.
             */
            id: string;
        };
        /**
         * The handler that is called when the element changes.
         */
        handler: (
        /**
         * An object describing the change that occurred.
         */
        change: ElementChangeCallbackParams) => void;
    }): VoidFunction;
    /**
     * Adds a listener for when an element group changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onElementGroupChange({
     *   options: { id: "element-group-1" },
     *   handler: elementGroup => console.log(elementGroup.id),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onElementGroupChange(args: {
        options: {
            id: string;
        };
        handler: (change: ElementGroupChangeCallbackParams) => void;
    }): VoidFunction;
}

/**
 * The Layers controller allows you to get information about the layers on the
 * map, and make changes to their visibility.
 *
 * Layers can be organised into groups, and their groups can also have their
 * visibility toggled.
 *
 * @group Controller
 * @public
 */
interface LayersController {
    /**
     * Get a single layer from the map by its id.
     *
     * @example
     * ```typescript
     * const layers = await felt.getLayer({ ids: ["layer-1", "layer-2"] });
     * ```
     * @returns The requested layer.
     */
    getLayer(
    /**
     * The id of the layer you want to get.
     */
    id: string): Promise<Layer | null>;
    /**
     * Gets layers from the map, according to the constraints supplied. If no
     * constraints are supplied, all layers will be returned.
     *
     * @remarks The layers in the map, ordered by the order specified in Felt. This is not
     * necessarily the order that they are drawn in, as Felt draws points above
     * lines and lines above polygons, for instance.
     *
     * @example
     * ```typescript
     * const layers = await felt.getLayers();
     * ```
     * @returns All layers on the map.
     */
    getLayers(
    /**
     * The constraints to apply to the layers returned from the map.
     */
    constraint?: GetLayersConstraint): Promise<Array<Layer | null>>;
    /**
     * Hide or show layers with the given ids.
     *
     * @example
     * ```typescript
     * felt.setLayerVisibility({ show: ["layer-1", "layer-2"], hide: ["layer-3"] });
     * ```
     */
    setLayerVisibility(visibility: SetVisibilityRequest): Promise<void>;
    /**
     * Set the style for a layer using FSL, the Felt Style Language.
     *
     * Changes are only for this session, and not persisted. This is useful to make
     * temporary changes to a layer's style, such as to highlight a particular layer
     * or feature.
     *
     * See the [FSL documentation](https://developers.felt.com/felt-style-language) for details
     * on how to read and write styles.
     *
     * If the style you set is invalid, you will receive an error explaining the problem
     * in the rejected promise value.
     *
     * @example
     * ```typescript
     * // first get the current style
     * const oldStyle = (await felt.getLayer("layer-1")).style;
     *
     * felt.setLayerStyle({ id: "layer-1", style: {
     *   ...oldStyle,
     *   paint: {
     *     ...oldStyle.paint,
     *     color: "red",
     *   },
     * } });
     * ```
     */
    setLayerStyle(params: {
        /**
         * The id of the layer to set the style for.
         */
        id: string;
        /**
         * The style to set for the layer.
         */
        style: object;
    }): Promise<void>;
    /**
     * Adds a listener for when a layer changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onLayerChange({
     *   options: { id: "layer-1" },
     *   handler: ({layer}) => console.log(layer.bounds),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onLayerChange(args: {
        options: {
            /**
             * The id of the layer to listen for changes to.
             */
            id: string;
        };
        /**
         * The handler that is called when the layer changes.
         */
        handler: (
        /**
         * An object describing the change that occurred.
         */
        change: LayerChangeCallbackParams) => void;
    }): VoidFunction;
    /**
     * Get a layer group from the map by its id.
     *
     * @example
     * ```typescript
     * felt.getLayerGroup("layer-group-1");
     * ```
     * @returns The requested layer group.
     */
    getLayerGroup(id: string): Promise<LayerGroup | null>;
    /**
     * Gets layer groups from the map, according to the constraints supplied. If no
     * constraints are supplied, all layer groups will be returned in rendering order.
     *
     * @example
     * ```typescript
     * const layerGroups = await felt.getLayerGroups({ ids: ["layer-group-1", "layer-group-2"] });
     * ```
     * @returns The requested layer groups.
     */
    getLayerGroups(
    /**
     * The constraints to apply to the layer groups returned from the map.
     */
    constraint?: GetLayerGroupsConstraint): Promise<Array<LayerGroup | null>>;
    /**
     * Hide or show layer groups with the given ids.
     *
     * @example
     * ```typescript
     * felt.setLayerGroupVisibility({ show: ["layer-group-1", "layer-group-2"], hide: ["layer-group-3"] });
     * ```
     */
    setLayerGroupVisibility(visibility: SetVisibilityRequest): Promise<void>;
    /**
     * Adds a listener for when a layer group changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onLayerGroupChange({
     *   options: { id: "layer-group-1" },
     *   handler: ({layerGroup}) => console.log(layerGroup.id),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onLayerGroupChange(args: {
        options: {
            id: string;
        };
        handler: (change: LayerGroupChangeCallbackParams) => void;
    }): VoidFunction;
    /**
     * Allows you to get the state of a single legend item.
     *
     * @example
     * ```typescript
     * const legendItem = await felt.getLegendItem({
     *   id: "legend-item-1",
     *   layerId: "layer-1",
     * })
     * ```
     */
    getLegendItem(id: LegendItemIdentifier): Promise<LegendItem | null>;
    /**
     * Allows you to obtain the state of several legend items, by passing in
     * constraints describing which legend items you want.
     *
     * If you do not pass any constraints, you will receive all legend items.
     *
     * @example
     * ```typescript
     * const legendItems = await felt.getLegendItems({layerId: "layer-1"});
     * ```
     */
    getLegendItems(constraint?: LegendItemsConstraint): Promise<Array<LegendItem | null>>;
    /**
     * Hide or show legend items with the given identifiers.
     *
     * @example
     * ```typescript
     * felt.setLegendItemVisibility({
     *   show: [{layerId: "layer-group-1", id: "item-1-0"}],
     *   hide: [{layerId: "layer-group-2", id: "item-2-0"}],
     * })
     * ```
     */
    setLegendItemVisibility(visibility: {
        show?: Array<LegendItemIdentifier>;
        hide?: Array<LegendItemIdentifier>;
    }): Promise<void>;
    /**
     * Adds a listener for when a legend item changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onLegendItemChange({
     *   options: { layerId: "layer-1", id: "item-1-0" },
     *   handler: ({legendItem}) => console.log(legendItem.visible),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onLegendItemChange(args: {
        options: LegendItemIdentifier;
        handler: (change: LegendItemChangeCallbackParams) => void;
    }): VoidFunction;
    /**
     * Get the filters for a layer.
     *
     * @remarks
     * The return type gives you the filters split up into the various sources
     * that make up the overall filters for a layer.
     *
     * @example
     * ```typescript
     * const filters = await felt.getLayerFilters("layer-1");
     * console.log(filters.combined, filters.style, filters.ephemeral, filters.components);
     * ```
     */
    getLayerFilters(layerId: string): Promise<LayerFilters | null>;
    /**
     * Sets the **ephemeral** filters for a layer.
     *
     * @example
     * ```typescript
     * felt.setLayerFilters({
     *   layerId: "layer-1",
     *   filters: ["AREA", "gt", 30_000],
     * });
     * ```
     */
    setLayerFilters(params: {
        /**
         * The layer that you want to set the filters for.
         */
        layerId: string;
        /**
         * The filters to set for the layer. This will replace any ephemeral filters
         * that are currently set for the layer.
         */
        filters: Filters;
        /**
         * A note to display on the layer legend when this filter is applied. When the
         * note is shown, a reset button will also be shown, allowing the user to clear
         * the filter.
         */
        note?: string;
    }): Promise<void>;
    /**
     * Get the features that are currently **rendered** on the map in the viewport.
     *
     * Note that this is explicitly about the features that are rendered, which isn't
     * necessarily a complete list of all the features in the viewport. This is because
     * of the way features are tiled: at low zoom levels or high feature densities, many
     * features are omitted from what is rendered on the screen.
     *
     * @example
     * ```typescript
     * const features = await felt.getRenderedFeatures();
     * ```
     */
    getRenderedFeatures(
    /**
     * The constraints to apply to the features returned from the map.
     */
    params?: GetRenderedFeaturesConstraint): Promise<Array<Feature>>;
}

/**
 * The Interactions controller allows you to observe interactions with the map
 *
 * @group Controller
 * @public
 */
interface InteractionsController {
    /**
     * Allows you to be notified the user clicks on the map.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onPointerClick({
     *   handler: (event) => console.log(event.center, event.features),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onPointerClick(params: {
        handler: (event: MapInteractionEvent) => void;
    }): VoidFunction;
    /**
     * Allows you to be notified the user moves the mouse over the map.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onPointerMove({
     *   handler: (event) => console.log(event.center, event.features),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onPointerMove(
    /**
     * Params for the listener
     */
    params: {
        /**
         * The handler function
         */
        handler: (event: MapInteractionEvent) => void;
    }): VoidFunction;
}

/**
 * The Selection controller allows you to listen for changes to the selection on the map.
 *
 * @group Controller
 * @public
 */
interface SelectionController {
    /**
     * Gets the current selection as a list of entity identifiers.
     *
     * @example
     * ```typescript
     * const selection = await felt.getSelection();
     * ```
     */
    getSelection(): Promise<EntityNode[]>;
    /**
     * Adds a listener for when the selection changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onSelectionChange({
     *   handler: ({selection}) => console.log(selection),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onSelectionChange(params: {
        handler: (change: {
            /**
             * The new selection. In the case where there are multiple entities selected,
             * the array describes the chronological and semeantic order of the selection.
             *
             * Entities of the same type that are selected later will appear later in the
             * list, but there are cases where multiple entity types can be selected at once,
             * such as elements and features. In this case, the order of the _types_ of entities
             * tells you which are considered more semantically important.
             *
             * For example, if a feature and element are selected, the feature will be at the
             * tail of the list because pressing Escape will deselect the feature first, then
             * pressing Escape again will deselect the element.
             */
            selection: EntityNode[];
        }) => void;
    }): VoidFunction;
    /**
     * Selects a feature on a layer. This will show the feature's popup, modal or
     * sidebar (if configured) and highlight the feature.
     *
     * @example
     * ```typescript
     * felt.selectFeature({
     *   id: 123,
     *   layerId: "my-layer",
     *   showPopup: true,
     *   fitViewport: { maxZoom: 15 },
     * });
     * ```
     */
    selectFeature(params: FeatureSelection): Promise<void>;
    /**
     * Clears the current selection. This clears the selection of
     *
     * @example
     * ```typescript
     *
     * // Removes all features and elements from the selection
     * felt.clearSelection();
     *
     * // Removes only features from the selection
     * felt.clearSelection({ features: true });
     *
     * // Removes only elements from the selection
     * felt.clearSelection({ elements: true });
     * ```
     *
     * @default
     * ```typescript
     * { features: true, elements: true }
     * ```
     *
     * @param params - The parameters to clear the selection. If this is not provided,
     * both features and elements will be cleared.
     */
    clearSelection(params?: {
        /**
         * Whether to clear the features from the selection.
         */
        features?: boolean;
        /**
         * Whether to clear the elements from the selection.
         */
        elements?: boolean;
    }): Promise<void>;
}

/**
 * @public
 */
interface UiControlsOptions extends zInfer<typeof UiControlsOptionsSchema> {
}
/**
 * @internal
 * @ignore
 */
declare const UiControlsOptionsSchema: z.ZodObject<{
    /**
     * Whether or not the legend is shown.
     *
     * @defaultValue true
     */
    showLegend: z.ZodOptional<z.ZodBoolean>;
    /**
     * When co-operative gestures are enabled, the pan and zoom gestures are
     * adjusted to work better when the map is embedded in another page.
     *
     * @remarks
     * On mobile devices, enabling co-operative gestures will allow the user to
     * pan past the embedded map with a single finger drag. To pan the map, they
     * must use two fingers.
     *
     * On desktop devices, enabling co-operative gestures allows the user to
     * scroll past the embedded map using their scroll wheel or trackpad. To
     * zoom the map, they must hold the Ctrl (Windows) or Command key (Mac) while
     * scrolling.
     *
     * @defaultValue true
     */
    cooperativeGestures: z.ZodOptional<z.ZodBoolean>;
    /**
     * Whether or not the full screen button is shown in an embedded map.
     *
     * @remarks
     * When clicked, this will open the map in a new tab or window.
     *
     * @defaultValue true
     */
    fullScreenButton: z.ZodOptional<z.ZodBoolean>;
    /**
     * Whether or not the geolocation button is shown in an embedded map.
     *
     * @remarks
     * The geolocation feature will plot your position on the map. If you
     * click the button again, it will start tracking your position.
     *
     * @defaultValue false
     */
    geolocation: z.ZodOptional<z.ZodBoolean>;
    /**
     * Whether or not the zoom controls are shown in an embedded map.
     *
     * @remarks
     * This does not affect whether or not the map can be zoomed, just
     * the display of the zoom controls in the bottom right corner of the map.
     *
     * @defaultValue true
     */
    zoomControls: z.ZodOptional<z.ZodBoolean>;
    /**
     * Whether or not the scale bar is shown in an embedded map.
     *
     * @defaultValue true
     */
    scaleBar: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    showLegend?: boolean | undefined;
    cooperativeGestures?: boolean | undefined;
    fullScreenButton?: boolean | undefined;
    geolocation?: boolean | undefined;
    zoomControls?: boolean | undefined;
    scaleBar?: boolean | undefined;
}, {
    showLegend?: boolean | undefined;
    cooperativeGestures?: boolean | undefined;
    fullScreenButton?: boolean | undefined;
    geolocation?: boolean | undefined;
    zoomControls?: boolean | undefined;
    scaleBar?: boolean | undefined;
}>;
/**
 * The options for which parts of the Felt UI can be shown when interacting with
 * features and elements on the map.
 *
 * Switching these off can be useful if you add your own click, selection or hover
 * handlers for features and elements.
 *
 * @public
 */
interface UiOnMapInteractionsOptions extends zInfer<typeof UiOnMapInteractionsOptionsSchema> {
}
/**
 * @internal
 * @ignore
 */
declare const UiOnMapInteractionsOptionsSchema: z.ZodObject<{
    /**
     * Set this to `false` to prevent the panel that shows information about a selected
     * feature from being shown.
     */
    featureSelectPanel: z.ZodOptional<z.ZodBoolean>;
    /**
     * Set this to `false` to prevent the panel that shows information about a hovered
     * feature from being shown.
     */
    featureHoverPanel: z.ZodOptional<z.ZodBoolean>;
    /**
     * Set this to `false` to prevent the panel that shows information about a selected
     * element from being shown.
     */
    elementSelectPanel: z.ZodOptional<z.ZodBoolean>;
    /**
     * Set this to `false` to prevent clicking on a map link element from opening that link
     * in a new tab or window.
     */
    linkClickOpen: z.ZodOptional<z.ZodBoolean>;
    /**
     * Set this to `false` to prevent clicking on an image element from opening the image
     * in a lightbox.
     */
    imageLightboxOpen: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    featureSelectPanel?: boolean | undefined;
    featureHoverPanel?: boolean | undefined;
    elementSelectPanel?: boolean | undefined;
    linkClickOpen?: boolean | undefined;
    imageLightboxOpen?: boolean | undefined;
}, {
    featureSelectPanel?: boolean | undefined;
    featureHoverPanel?: boolean | undefined;
    elementSelectPanel?: boolean | undefined;
    linkClickOpen?: boolean | undefined;
    imageLightboxOpen?: boolean | undefined;
}>;

/**
 * The UI controller allows you to enable and disable UI controls on the
 * embedded map.
 *
 * @group Controller
 * @public
 */
interface UiController {
    /**
     * Updates the UI controls on the embedded map.
     *
     * @param controls - The controls to update.
     */
    updateUiControls(controls: UiControlsOptions): void;
    /**
     * Control the on-map UI shown when interacting with features and elements.
     *
     * If you add your own click, selection or hover handlers you may want to disable
     * various parts of the Felt UI. This method allows you to control the visibility of
     * various parts of the UI that might otherwise be shown when people click or hover
     * on things.
     *
     * This does not affect selection. That means that selectable features and elements
     * will still be selected when clicked.
     */
    setOnMapInteractionsUi(options: UiOnMapInteractionsOptions): void;
}

/**
 * The viewport controller allows you to control the viewport of the map.
 *
 * You can get the current viewport, move the viewport, and be notified when
 * the viewport changes.
 *
 * @group Controller
 * @public
 */
interface ViewportController {
    /**
     * Gets the current state of the viewport.
     */
    getViewport(): Promise<ViewportState>;
    /**
     * Moves the map to the specified location.
     *
     * @example
     * ```typescript
     * felt.setViewport({
     *   center: { latitude: 0, longitude: 0 },
     *   zoom: 10,
     * });
     * ```
     */
    setViewport(viewport: SetViewportCenterZoomParams): void;
    /**
     * Fits the map to the specified bounds.
     *
     * @example
     * ```typescript
     * const west = -122.4194;
     * const south = 37.7749;
     * const east = -122.4194;
     * const north = 37.7749;
     * felt.fitViewportToBounds({ bounds: [west, south, east, north] });
     * ```
     */
    fitViewportToBounds(bounds: ViewportFitBoundsParams): void;
    /**
     * Adds a listener for when the viewport changes.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onViewportMove({
     *   handler: viewport => console.log(viewport.center.latitude),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onViewportMove(args: {
        /**
         * This callback is called with the current viewport state whenever
         * the viewport changes.
         *
         * @param viewport - The current viewport state.
         */
        handler: (viewport: ViewportState) => void;
    }): VoidFunction;
    /**
     * Adds a listener for when the viewport move ends, which is when the user
     * stops dragging or zooming the map, animations have finished, or inertial
     * dragging ends.
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onViewportMoveEnd({
     *   handler: viewport => console.log(viewport.center.latitude),
     * });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onViewportMoveEnd(args: {
        handler: (viewport: ViewportState) => void;
    }): VoidFunction;
    /**
     * Adds a listener for when the map is idle, which is defined as:
     * - No transitions are in progress
     * - The user is not interacting with the map, e.g. by panning or zooming
     * - All tiles for the current viewport have been loaded
     * - Any fade transitions (e.g. for labels) have completed
     *
     * @returns A function to unsubscribe from the listener
     *
     * @event
     * @example
     * ```typescript
     * const unsubscribe = felt.onMapIdle({ handler: () => console.log("map is idle") });
     *
     * // later on...
     * unsubscribe();
     * ```
     */
    onMapIdle(args: {
        handler: () => void;
    }): VoidFunction;
}

/**
 * This is the main interface for interacting with a Felt map.
 *
 * This interface is composed of the various controllers, each having a
 * different area of responsibility.
 *
 * All the methods are listed here, but each controller is documented on its
 * own to make it easier to find related methods and events.
 *
 * @group Controller
 * @public
 */
interface FeltController extends ViewportController, UiController, LayersController, ElementsController, SelectionController, InteractionsController {
    /**
     * The iframe element containing the Felt map, if it is an embedded map.
     *
     * @readonly
     */
    iframe: HTMLIFrameElement | null;
}

/**
 * @group Instantiation
 * @public
 */
interface FeltEmbedOptions extends zInfer<typeof FeltEmbedOptionsSchema> {
    uiControls?: UiControlsOptions;
    initialViewport?: ViewportCenterZoom;
}
/**
 * @internal
 */
declare const FeltEmbedOptionsSchema: z.ZodObject<{
    /**
     * @hidden
     */
    origin: z.ZodOptional<z.ZodString>;
    /**
     * An authentication token to use for showing embeds that are configured to be
     * private.
     */
    token: z.ZodOptional<z.ZodString>;
    uiControls: z.ZodOptional<z.ZodObject<{
        showLegend: z.ZodOptional<z.ZodBoolean>;
        cooperativeGestures: z.ZodOptional<z.ZodBoolean>;
        fullScreenButton: z.ZodOptional<z.ZodBoolean>;
        geolocation: z.ZodOptional<z.ZodBoolean>;
        zoomControls: z.ZodOptional<z.ZodBoolean>;
        scaleBar: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        showLegend?: boolean | undefined;
        cooperativeGestures?: boolean | undefined;
        fullScreenButton?: boolean | undefined;
        geolocation?: boolean | undefined;
        zoomControls?: boolean | undefined;
        scaleBar?: boolean | undefined;
    }, {
        showLegend?: boolean | undefined;
        cooperativeGestures?: boolean | undefined;
        fullScreenButton?: boolean | undefined;
        geolocation?: boolean | undefined;
        zoomControls?: boolean | undefined;
        scaleBar?: boolean | undefined;
    }>>;
    initialViewport: z.ZodOptional<z.ZodObject<{
        center: z.ZodObject<{
            latitude: z.ZodNumber;
            longitude: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            latitude: number;
            longitude: number;
        }, {
            latitude: number;
            longitude: number;
        }>;
        zoom: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        center: {
            latitude: number;
            longitude: number;
        };
        zoom: number;
    }, {
        center: {
            latitude: number;
            longitude: number;
        };
        zoom: number;
    }>>;
}, "strip", z.ZodTypeAny, {
    origin?: string | undefined;
    token?: string | undefined;
    uiControls?: {
        showLegend?: boolean | undefined;
        cooperativeGestures?: boolean | undefined;
        fullScreenButton?: boolean | undefined;
        geolocation?: boolean | undefined;
        zoomControls?: boolean | undefined;
        scaleBar?: boolean | undefined;
    } | undefined;
    initialViewport?: {
        center: {
            latitude: number;
            longitude: number;
        };
        zoom: number;
    } | undefined;
}, {
    origin?: string | undefined;
    token?: string | undefined;
    uiControls?: {
        showLegend?: boolean | undefined;
        cooperativeGestures?: boolean | undefined;
        fullScreenButton?: boolean | undefined;
        geolocation?: boolean | undefined;
        zoomControls?: boolean | undefined;
        scaleBar?: boolean | undefined;
    } | undefined;
    initialViewport?: {
        center: {
            latitude: number;
            longitude: number;
        };
        zoom: number;
    } | undefined;
}>;

/**
 * Use the {@link Felt} object to embed a new iframe, or connect to an existing embedded
 * iframe.
 *
 * Once you have connected to a Felt map (either by embedding or connecting to an existing
 * iframe), you can use the {@link FeltController} object to control the map.
 *
 * To see what you can do with the map, see the documentation for the {@link FeltController}
 * interface and its constituent controllers.
 *
 * @example
 * ```typescript
 * // embed the map
 * const map = await Felt.embed(container, "felt-map-abc-123");
 *
 * // now the map is loaded and connected, you can use the FeltController interface
 * // to control the map. For instance, to get information about the layers
 * const layers = await map.getLayers();
 *
 * // Or to set the viewport to a specific location and zoom level
 * await map.setViewport({
 *   center: { latitude: 37.8113, longitude: -122.2682 },
 *   zoom: 10,
 * });
 * ```
 *
 * @module Main
 */

/**
 * The Felt SDK is a library for embedding Felt maps into your website,
 * allowing you to control and inspect the map programmatically.
 *
 * @public
 *
 * @group Instantiation
 */
declare const Felt: {
    /**
     * Embeds a Felt map into the provided container.
     *
     * @param container - The container element to embed the map into.
     * @param mapId - The ID of the map to embed.
     * @param options - The options to configure the map.
     * @returns
     */
    embed(container: HTMLElement, mapId: string, options?: FeltEmbedOptions): Promise<FeltController>;
    /**
     * Binds to an existing Felt map iframe.
     *
     * @param feltWindow - The iframe element containing the Felt map.
     * @returns
     */
    connect(feltWindow: Window): Promise<FeltController>;
};

export { Element, ElementChangeCallbackParams, ElementGroup, ElementGroupChangeCallbackParams, type ElementsController, EntityNode, Feature, FeatureSelection, Felt, type FeltController, type FeltEmbedOptions, Filters, Geometry, GetElementGroupsConstraint, GetElementsConstraint, GetLayerGroupsConstraint, GetLayersConstraint, GetRenderedFeaturesConstraint, type InteractionsController, Layer, LayerChangeCallbackParams, LayerFilters, LayerGroup, LayerGroupChangeCallbackParams, type LayersController, LegendItem, LegendItemChangeCallbackParams, LegendItemIdentifier, LegendItemsConstraint, MapInteractionEvent, type UiOnMapInteractionsOptions as OnMapInteractionsOptions, type SelectionController, SetViewportCenterZoomParams, SetVisibilityRequest, type UiController, type UiControlsOptions, ViewportCenterZoom, type ViewportController, ViewportFitBoundsParams, ViewportState };
